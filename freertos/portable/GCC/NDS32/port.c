/*
 * FreeRTOS Kernel V10.1.1
 * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software. If you wish to use our Amazon
 * FreeRTOS name, please do so in a fair use way that does not cause confusion.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * http://www.FreeRTOS.org
 * http://aws.amazon.com/freertos
 *
 * 1 tab == 4 spaces!
 */

/*-----------------------------------------------------------
 * Implementation of functions defined in portmacro.h for the NDS32 port.
 *----------------------------------------------------------*/

/* Scheduler includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "ISR_Support.h"

#ifndef configMAX_API_CALL_INTERRUPT_PRIORITY
    #define configMAX_API_CALL_INTERRUPT_PRIORITY
    #error configMAX_API_CALL_INTERRUPT_PRIORITY must be defined.
#endif

#if( ( configMAX_API_CALL_INTERRUPT_PRIORITY > 3 ) || ( configMAX_API_CALL_INTERRUPT_PRIORITY < 0 ) )
    #error configMAX_API_CALL_INTERRUPT_PRIORITY must be between 0 and 3
#endif

#ifndef configIRQ_SWI_VECTOR
    #error configIRQ_SWI_VECTOR must be defined in FreeRTOSConfig.h to have SWI to perform context switch.
#endif

#ifndef configSETUP_TICK_INTERRUPT
    #error configSETUP_TICK_INTERRUPT() must be defined in FreeRTOSConfig.h to call the function that sets up the tick interrupt.
#endif

#ifndef configCLEAR_TICK_INTERRUPT
    #error configCLEAR_TICK_INTERRUPT must be defined in FreeRTOSConfig.h to clear which ever interrupt was used to generate the tick interrupt.
#endif


/* Constants required to set up the initial stack. */
#define portPSW_GIE         ( 1UL << 0UL )
#define portPSW_AEN         ( 1UL << 13UL )
#define portPSW_IFCON       ( 1UL << 15UL )
#define portPSW_CPL         ( 7UL << 16UL )

#if ( configSUPPORT_ZOL == 1 )
    /* Default task PSW: enable GIE and AEN, set CPL to 7, clear IFCON */
    #define portINITIAL_PSW         ( ( __nds32__mfsr( NDS32_SR_PSW ) | portPSW_GIE | portPSW_CPL | portPSW_AEN ) & ~portPSW_IFCON )
#else
    /* Default task PSW: enable GIE, set CPL to 7, clear IFCON */
    #define portINITIAL_PSW         ( ( __nds32__mfsr( NDS32_SR_PSW ) | portPSW_GIE | portPSW_CPL ) & ~portPSW_IFCON )
#endif

/*-----------------------------------------------------------*/

/* Each task maintains its own interrupt status in the critical nesting
variable. */
static volatile UBaseType_t     uxCriticalNesting = 0xaaaaaaaa;

#if( configUSE_TICKLESS_IDLE == 1 )
    /* Flag set from the tick interrupt to allow the sleep processing to know if
    sleep mode was exited because of a tick interrupt, or an interrupt
    generated by something else. */
    static volatile BaseType_t  xTickFlag = pdFALSE;
#endif /* configUSE_TICKLESS_IDLE */

/*-----------------------------------------------------------*/

/*
 * Start first task is a separate function so it can be tested in isolation.
 */
extern void vPortStartFirstTask( void );

/*
 * Used to catch tasks that attempt to return from their implementing function.
 */
static void prvTaskExitError( void );

/*-----------------------------------------------------------*/

/*
 * Initialise the stack of a task to look exactly as if a call to
 * portSAVE_CONTEXT had been called.
 *
 * Stack Layout:
 *                High  |-----------------|
 *                      |       $R30 (LP) |
 *                      |-----------------|
 *                      |       $R29 (GP) |
 *                      |-----------------|
 *                      |       $R28 (FP) |
 *                      |-----------------|
 *                      |   $R15 | $R25   |
 *                      |-----------------|
 *                      |   $R10 | $R24   |
 *                      |-----------------|
 *                      |        .        |
 *                      |        .        |
 *                      |-----------------|
 *                      |       $R0       |
 *                      |-----------------|
 *                      |       $IFC_LP   | ( configSUPPORT_IFC )
 *                      |-----------------|
 *                      |   $LC/$LE/$LB   | ( configSUPPORT_ZOL )
 *                      |       (ZOL)     |
 *                      |-----------------|
 *                      |       $IPSW     |
 *                      |-----------------|
 *                      |       $IPC      |
 *                      |-----------------|
 *                      |    Dummy word   | ( Dummy word for 8-byte stack pointer alignment )
 *                      |-----------------|
 *                      |       $FPU      | ( configSUPPORT_FPU )
 *                      |-----------------|
 *                Low
 *
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    /* Simulate the stack frame as it would be created by a context switch
    interrupt. */
extern uint32_t _SDA_BASE_ __attribute__ ((weak));

    /* R0 ~ R30 registers */
    *--pxTopOfStack = ( StackType_t ) prvTaskExitError;/* R30 : $lp */
    *--pxTopOfStack = ( StackType_t ) &_SDA_BASE_;  /* R29 : $GP */
    *--pxTopOfStack = ( StackType_t ) 0x1c;     /* R28 */
#ifdef __NDS32_REDUCE_REGS__
    *--pxTopOfStack = ( StackType_t ) 0x0f;     /* R15 */
#else
    *--pxTopOfStack = ( StackType_t ) 0x19;     /* R25 */
    *--pxTopOfStack = ( StackType_t ) 0x18;     /* R24 */
    *--pxTopOfStack = ( StackType_t ) 0x17;     /* R23 */
    *--pxTopOfStack = ( StackType_t ) 0x16;     /* R22 */
    *--pxTopOfStack = ( StackType_t ) 0x15;     /* R21 */
    *--pxTopOfStack = ( StackType_t ) 0x14;     /* R20 */
    *--pxTopOfStack = ( StackType_t ) 0x13;     /* R19 */
    *--pxTopOfStack = ( StackType_t ) 0x12;     /* R18 */
    *--pxTopOfStack = ( StackType_t ) 0x11;     /* R17 */
    *--pxTopOfStack = ( StackType_t ) 0x10;     /* R16 */
    *--pxTopOfStack = ( StackType_t ) 0x0f;     /* R15 */
    *--pxTopOfStack = ( StackType_t ) 0x0e;     /* R14 */
    *--pxTopOfStack = ( StackType_t ) 0x0d;     /* R13 */
    *--pxTopOfStack = ( StackType_t ) 0x0c;     /* R12 */
    *--pxTopOfStack = ( StackType_t ) 0x0b;     /* R11 */
#endif
    *--pxTopOfStack = ( StackType_t ) 0x0a;     /* R10 */
    *--pxTopOfStack = ( StackType_t ) 0x09;         /* R9 */
    *--pxTopOfStack = ( StackType_t ) 0x08;     /* R8 */
    *--pxTopOfStack = ( StackType_t ) 0x07;     /* R7 */
    *--pxTopOfStack = ( StackType_t ) 0x06;     /* R6 */
    *--pxTopOfStack = ( StackType_t ) 0x05;     /* R5 */
    *--pxTopOfStack = ( StackType_t ) 0x04;     /* R4 */
    *--pxTopOfStack = ( StackType_t ) 0x03;     /* R3 */
    *--pxTopOfStack = ( StackType_t ) 0x02;     /* R2 */
    *--pxTopOfStack = ( StackType_t ) 0x01;     /* R1 */
    *--pxTopOfStack = ( StackType_t ) pvParameters; /* R0 : Argument */

#if ( configSUPPORT_IFC == 1 )
    /* IFC system register */
    *--pxTopOfStack = ( StackType_t ) 0x00;     /* IFC_LP */
#endif

#if ( configSUPPORT_ZOL == 1 )
    /* ZOL system registers */
    *--pxTopOfStack = ( StackType_t ) 0x00;     /* LC */
    *--pxTopOfStack = ( StackType_t ) 0x00;     /* LE */
    *--pxTopOfStack = ( StackType_t ) 0x00;     /* LB */
#endif

    /* IPSW and IPC system registers */
    *--pxTopOfStack = ( StackType_t ) portINITIAL_PSW;  /* IPSW */
    *--pxTopOfStack = ( StackType_t ) pxCode;       /* IPC : First instruction PC of task */

#if ( ( configSUPPORT_IFC == 1 ) && ( configSUPPORT_ZOL == 1 ) || ( configSUPPORT_IFC != 1 ) && ( configSUPPORT_ZOL != 1 ) )
    /* Dummy word for 8-byte stack alignment */
    *--pxTopOfStack = (portSTACK_TYPE) -1;
#endif

#if ( configSUPPORT_FPU == 1 )
    /* FPU registers */
    pxTopOfStack -= portFPU_REGS;
#endif

    return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
    /* A function that implements a task must not exit or attempt to return to
    its caller as there is nothing to return to.  If a task wants to exit it
    should instead call vTaskDelete( NULL ).

    Artificially force an assert() to be triggered if configASSERT() is
    defined, then stop here so application writers can catch the error. */
    configASSERT( uxCriticalNesting == ~0UL );
    portDISABLE_INTERRUPTS();
    for( ;; );
}
/*-----------------------------------------------------------*/

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
    /* Make Software interrupt the lowest priority interrupts. */
#if ( configIRQ_SWI_VECTOR < 16 )
    __nds32__mtsr( __nds32__mfsr( NDS32_SR_INT_PRI ) | ( 3 << ( ( configIRQ_SWI_VECTOR ) << 1 ) ), NDS32_SR_INT_PRI );
#else
    __nds32__mtsr( __nds32__mfsr( NDS32_SR_INT_PRI2 ) | ( 3 << ( ( ( configIRQ_SWI_VECTOR ) - 16 ) << 1 ) ), NDS32_SR_INT_PRI2 );
#endif
    __nds32__mtsr( __nds32__mfsr( NDS32_SR_INT_MASK2 ) | ( 1 << ( configIRQ_SWI_VECTOR ) ), NDS32_SR_INT_MASK2 );

    /* Start the timer that generates the tick ISR.  Interrupts are disabled
    here already. */
    /* Call an application function to set up the timer that will generate the
    tick interrupt.  This way the application can decide which peripheral to
    use.  A demo application is provided to show a suitable example. */
    configSETUP_TICK_INTERRUPT();

    /* Initialise the critical nesting count ready for the first task. */
    uxCriticalNesting = 0;

    /* Start the first task. */
    vPortStartFirstTask();

    /* Should not get here! */
    return 0;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    /* Not implemented in ports where there is nothing to return to.
    Artificially force an assert. */
    configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    portDISABLE_INTERRUPTS();
    uxCriticalNesting++;
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
    configASSERT( uxCriticalNesting );
    uxCriticalNesting--;
    if( uxCriticalNesting == 0 )
    {
        portENABLE_INTERRUPTS();
    }
}
/*-----------------------------------------------------------*/

void FreeRTOS_Tick_Handler( void )
{
    /* The SysTick runs at the lowest interrupt priority, so when this interrupt
    executes all interrupts must be unmasked. */
uint32_t ulPreviousMask;

    configCLEAR_TICK_INTERRUPT();
    ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        /* Increment the RTOS tick. */
        if( xTaskIncrementTick() != pdFALSE )
        {
            /* A context switch is required.  Context switching is performed in
            the SWI interrupt.  Pend the SWI interrupt. */
            portYIELD();
        }

    #if( configUSE_TICKLESS_IDLE == 1 )
        xTickFlag = pdTRUE;
    #endif /* configUSE_TICKLESS_IDLE */
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
}
/*-----------------------------------------------------------*/

#if( configUSE_TICKLESS_IDLE == 1 )
    __attribute__((weak)) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
    {
        /* The number of Timer's cycle that make up one tick period. */
        #define portUL_TIMER_COUNTS_FOR_ONE_TICK        ( (uint32_t)( configPERIPHERAL_CLOCK_HZ / configTICK_RATE_HZ ) )

        /* The maximum number of tick periods that can be suppressed is limited by the
        resolution of the Timer. */
        #define portMAXIMUM_POSSIBLE_SUPPRESSED_TICKS   ( ( UINT32_MAX - 1 ) / portUL_TIMER_COUNTS_FOR_ONE_TICK )

        /* Compensate for the CPU cycles that pass while the Timer is stopped/disabled */
        #define portUL_STOPPED_TIMER_COMPENSATION       ( (uint32_t) 0 )

        uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
        TickType_t xModifiableIdleTime;

        /* Make sure the Timer reload value does not overflow the Timer resolution. */
        if( xExpectedIdleTime > portMAXIMUM_POSSIBLE_SUPPRESSED_TICKS )
        {
            xExpectedIdleTime = portMAXIMUM_POSSIBLE_SUPPRESSED_TICKS;
        }

        /* Read the Timer counter and then stop(disable) the Timer momentarily.
        The time the Timer is stopped for is accounted for as best it can be,
        but using the tickless mode will inevitably result in some tiny drift of
        the time maintained by the kernel with respect to calendar time. */
        uint32_t ulRemainTimerCounts = configGET_TICK_COUNTER();
        __nds32__gie_dis();
        uint32_t ulRemainTimerCounts2 = configGET_TICK_COUNTER();

        if( ulRemainTimerCounts2 > ulRemainTimerCounts )
        {
            /* Timer overflow occurs between 2 configGET_TICK_COUNTER() calls. */

            /* Enable interrupts to allow the Timer interrupt to execute
            immediately. */
            __nds32__gie_en();

            /* Read the Timer counter after Timer overflow. */
            ulRemainTimerCounts = configGET_TICK_COUNTER();

            /* Stop Timer. */
            configENABLE_TICK_INTERRUPT( pdFALSE );
        }
        else
        {
            /* Stop Timer. */
            configENABLE_TICK_INTERRUPT( pdFALSE );

            /* Clear Timer interrupt which occurs after 2nd
            configGET_TICK_COUNTER() call. */
            configCLEAR_TICK_INTERRUPT();

            /* Enable interrupts. */
            __nds32__gie_en();
        }

        /* Calculate the reload value required to wait xExpectedIdleTime
        tick periods. -1 is used because this code will execute part way
        through one of the tick periods. */
        ulReloadValue = ulRemainTimerCounts + ( portUL_TIMER_COUNTS_FOR_ONE_TICK * ( xExpectedIdleTime - 1UL ) );
        if( ulReloadValue > portUL_STOPPED_TIMER_COMPENSATION )
        {
            ulReloadValue -= portUL_STOPPED_TIMER_COMPENSATION;
        }

        /* Enter a critical section but don't use the taskENTER_CRITICAL()
        method as that will mask interrupts that should exit sleep mode. */
        __nds32__gie_dis();

        /* If a context switch is pending or a task is waiting for the scheduler
        to be unsuspended then abandon the low power entry. */
        if( eTaskConfirmSleepModeStatus() == eAbortSleep )
        {
            /* Restart from whatever is left in the count register to complete
            this tick period. */
            configSET_TICK_RELOAD( ulRemainTimerCounts );
            configENABLE_TICK_INTERRUPT( pdTRUE );

            /* Reset the reload register to the value required for normal tick
            periods. */
            configSET_TICK_RELOAD( portUL_TIMER_COUNTS_FOR_ONE_TICK );

            /* Re-enable interrupts. */
            __nds32__gie_en();
        }
        else
        {
            /* The tick flag is set to false before sleeping. If it is true when
            sleep mode is exited then sleep mode was probably exited because the
            tick was suppressed for the entire xExpectedIdleTime period. */
            xTickFlag = pdFALSE;

            /* Set the new reload value. */
            configSET_TICK_RELOAD( ulReloadValue );

            /* Restart Timer. */
            configENABLE_TICK_INTERRUPT( pdTRUE );

            /* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
            set its parameter to 0 to indicate that its implementation contains
            its own wait for interrupt or wait for event instruction, and so wfi
            should not be executed again.  However, the original expected idle
            time variable must remain unmodified, so a copy is taken. */
            xModifiableIdleTime = xExpectedIdleTime;
            configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
            if( xModifiableIdleTime > 0 )
            {
                __nds32__standby_no_wake_grant();
            }
            configPOST_SLEEP_PROCESSING( xExpectedIdleTime );

            /* Re-enable interrupts to allow the interrupt that brought the MCU
            out of sleep mode to execute immediately. */
            __nds32__gie_en();

            /* Read the Timer counter and then stop(disable) the Timer. Again,
            The time the Timer is stopped for is accounted for as best it can be,
            but using the tickless mode will inevitably result in some
            tiny drift of the time maintained by the kernel with respect to
            calendar time. */
            ulRemainTimerCounts = configGET_TICK_COUNTER();

            /* Disable interrupts again because the clock is about to be stopped
            and interrupts that execute while the clock is stopped will increase
            any slippage between the time maintained by the RTOS and calendar
            time. */
            __nds32__gie_dis();

            /* Determine if the Timer clock has already counted to zero and
            been set back to the current reload value (the reload back being
            correct for the entire expected idle time) or if the Timer is yet
            to count to zero (in which case an interrupt other than the Timer
            must have brought the system out of sleep mode). */
            if( xTickFlag == pdTRUE )
            {
                /* Enable interrupts to allow the Timer interrupt to execute
                immediately. */
                __nds32__gie_en();

                /* Then, disable interrupt for previous reason. */
                __nds32__gie_dis();

                /* Read the Timer counter after Timer overflow. */
                ulRemainTimerCounts = configGET_TICK_COUNTER();

                /* Stop Timer. */
                configENABLE_TICK_INTERRUPT( pdFALSE );

                uint32_t ulCalculatedLoadValue;
                /* The tick interrupt is already pending, and the Timer counter
                reloaded with ulReloadValue.  Reset the reload value
                with whatever remains of this tick period. */
                ulCalculatedLoadValue = ( portUL_TIMER_COUNTS_FOR_ONE_TICK - 1UL ) - ( ulReloadValue - ulRemainTimerCounts );

                /* Don't allow a tiny value, or values that have somehow
                underflowed because the post sleep hook did something
                that took too long. */
                if( ( ulCalculatedLoadValue < portUL_STOPPED_TIMER_COMPENSATION ) || ( ulCalculatedLoadValue > portUL_TIMER_COUNTS_FOR_ONE_TICK ) )
                {
                    ulCalculatedLoadValue = ( portUL_TIMER_COUNTS_FOR_ONE_TICK - 1UL );
                }

                configSET_TICK_RELOAD( ulCalculatedLoadValue );

                /* As the pending tick will be processed as soon as this
                function exits, the tick value maintained by the tick is stepped
                forward by one less than the time spent waiting. */
                ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
            }
            else
            {
                /* Stop Timer. */
                configENABLE_TICK_INTERRUPT( pdFALSE );

                /* Clear Timer interrupt which occurs after GIE disabled */
                configCLEAR_TICK_INTERRUPT();

                /* Something other than the tick interrupt ended the sleep.
                Work out how long the sleep lasted rounded to complete tick
                periods (not the ulReload value which accounted for part
                ticks). */
                ulCompletedSysTickDecrements = ( xExpectedIdleTime * portUL_TIMER_COUNTS_FOR_ONE_TICK ) - ulRemainTimerCounts;

                /* How many complete tick periods passed while the processor
                was waiting? */
                ulCompleteTickPeriods = ulCompletedSysTickDecrements / portUL_TIMER_COUNTS_FOR_ONE_TICK;

                /* The reload value is set to whatever fraction of a single tick
                period remains. */
                configSET_TICK_RELOAD( ( ( ulCompleteTickPeriods + 1UL ) * portUL_TIMER_COUNTS_FOR_ONE_TICK ) - ulCompletedSysTickDecrements );
            }

            /* Restart Timer so it runs from Timer reload again, then set
            reload value back to its standard value. */
            configENABLE_TICK_INTERRUPT( pdTRUE );
            vTaskStepTick( ulCompleteTickPeriods );
            configSET_TICK_RELOAD( portUL_TIMER_COUNTS_FOR_ONE_TICK );

            /* Exit with interrpts enabled. */
            __nds32__gie_en();
        }
    }
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

    void vPortValidateInterruptPriority( void )
    {
#if ( configMAX_API_CALL_INTERRUPT_PRIORITY != 0 )
    uint8_t ucCurrentPriority;


        /* Obtain the number of the currently executing interrupt. */
        ucCurrentPriority = ( ( __nds32__mfsr( NDS32_SR_PSW ) & portPSW_CPL_MASK ) >> 16UL );

        /* The following assertion will fail if a service routine (ISR) for
        an interrupt that has been assigned a priority above
        configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
        function.  ISR safe FreeRTOS API functions must *only* be called
        from interrupts that have been assigned a priority at or below
        configMAX_SYSCALL_INTERRUPT_PRIORITY.

        Numerically low interrupt priority numbers represent logically high
        interrupt priorities, therefore the priority of the interrupt must
        be set to a value equal to or numerically *higher* than
        configMAX_SYSCALL_INTERRUPT_PRIORITY.

        FreeRTOS maintains separate thread and ISR API functions to ensure
        interrupt entry is as fast and simple as possible. */
        configASSERT( ucCurrentPriority >= configMAX_API_CALL_INTERRUPT_PRIORITY );
#endif
    }

#endif /* configASSERT_DEFINED */
